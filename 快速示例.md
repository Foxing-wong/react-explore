1. 渲染一个虚拟 DOM 为真实 DOM
    
    file: demo/render/
    
    使用 render() 方法生成真实 DOM 并插入到网页中。

2. 设置初始数据

    file: demo/get-initial-state
    
    第一次渲染真实 DOM 时将使用 getInitialState() 返回的数据
    
3. 动态更新数据
    
    file: demo/set-state

    第二次更新渲染真实 DOM 时将使用 setState() 设置的数据

4. 绑定事件

    file: demo/events
    
    绑定事件时，我们可以使用 ref="name" 属性对一个 DOM 节点进行标记，同时可以通过 React.findDOMNode(this.refs.name) 获取到这个节点的原生 DOM。
    
5. 多组件与组件嵌套

    file: demo/multi-components

一个组件就包含了 JSX 模板、数据维护、事件绑定的话，代码量已经够多了，这时候可以采用 AMD/CMD 的方式，将组件进行更细粒度的划分，可以以文件即组件的方式来编写，这里就不上 demo 了。

6. 组件间通信
    
    file: demo/comunications

    在 React 中，数据流是单向的，且组件之间可以嵌套，我们可以通过对最顶层组件传递属性方式，向下层组件传送数据。
    
    - 嵌套组件间，使用 this.props  属性向下传递数据
    
        file: demo/comunications/index.html
        
    - 独立组件之间，自行维护数据
    
        file: demo/comunications/index.html
    
    则需要自行维护一个全局数据存储，或者使用发布订阅地方式通知数据的更新。
    全局数据存储怎么做呢？可以理解为不同的组件获取的数据源一致，在组件的外部维护这个数据集合，或者干脆直接从服务器端获取。
    有人会说了，这样很不方便。
    但我觉得，既然是一个组件，那就配套有获取组件所需数据的方式，独立组件间有很强的数据依赖时，要么使用上述方式，要么可以简单粗暴，将独立组件用一个顶层组件包裹起来，转化为嵌套组件的关系，即可数据互通。    
    
7. 丝滑的构建 使用 ES6 + webpack + gulp

    gulp 的话就不多介绍啦。
    
    Webpack 是一款新生的前端构建工具，兼容 AMD/CMD 等写法，支持 Browser 和 Node 端共享代码，在浏览器端可以像写 Node 一样方便的进行模块化的划分。
    
    要
    
    使用 jsx-loader 这个插件支持 jsx 语法解析
    
    使用 esx-loader 这个插件支持 es6 语法解析
    
    来看下简单目录结构：
    
    js/main.js 为入口文件，引入了两个组件。
    
        - js/components/movie-list.js 组件为 JSX 语法编写
    
        - js/components/hello.js 组件为 ES6 + JSX 语法编写
    
    在 js/main.js 中引入两个不同的组件，然后在 webpack.config.js 中指定编译 JSX 和 ES6 的 loader 工具，使用 gulp 监听 js/ 中文件变化，自动编译出的 js/bundle.js 将被 index.html 引用。
    
    嗯，再在 webpack 中加入各种你喜欢的 loader，在 gulp 中加上各种 css、js、img 的处理任务，纵享丝滑。
    
    

    






